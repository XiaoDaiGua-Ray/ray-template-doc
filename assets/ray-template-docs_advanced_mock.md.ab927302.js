import{_ as s,o as a,c as n,V as l}from"./chunks/framework.51f721ee.js";const d=JSON.parse('{"title":"mock 数据","description":"","frontmatter":{},"headers":[],"relativePath":"ray-template-docs/advanced/mock.md","filePath":"ray-template-docs/advanced/mock.md","lastUpdated":1702620843000}'),o={name:"ray-template-docs/advanced/mock.md"},p=l(`<h1 id="mock-数据" tabindex="-1">mock 数据 <a class="header-anchor" href="#mock-数据" aria-label="Permalink to &quot;mock 数据&quot;">​</a></h1><div class="danger custom-block"><p class="custom-block-title">注意</p><p>千万不要在 <code>src</code> 文件中引入使用 <code>mock</code> 中的方法或者文件，同理也不要在 <code>mock</code> 中引入 <code>src</code> 的相关方法或者文件。</p></div><p>Mock.js是一个前端开发中常用的模拟数据生成工具。它可以帮助开发者在前端环境中快速生成随机数据，用于模拟后端接口的返回数据，以便进行开发和测试。Mock.js的主要作用如下：</p><ul><li>模拟后端接口：在前端开发中，通常需要与后端进行接口对接。然而，当后端接口尚未开发完成或者无法访问时，前端开发者可以使用Mock.js生成模拟数据，以便进行前端页面的开发和调试。Mock.js可以根据指定的数据模板，生成符合要求的随机数据，包括字符串、数字、布尔值、数组、对象等</li><li>快速生成测试数据：在进行单元测试或集成测试时，通常需要一些测试数据来验证代码的正确性和稳定性。Mock.js可以根据指定的数据规则，生成大量的随机数据，用于测试不同情况下的代码逻辑</li><li>前后端分离开发：在前后端分离的开发模式中，前端开发者可以使用Mock.js快速生成模拟数据，进行前端开发和调试，而无需等待后端接口的完成。这样可以提高开发效率，并且减少前后端的耦合度</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>但是，以个人的经验来讲。mock 数据会增加自己的一定工作量，如果是简单的数据，不如自己手写几个简单数据来的快。</p></div><h2 id="vite-plugin-mock-dev-server" tabindex="-1">vite-plugin-mock-dev-server <a class="header-anchor" href="#vite-plugin-mock-dev-server" aria-label="Permalink to &quot;vite-plugin-mock-dev-server&quot;">​</a></h2><p>模板采用 <a href="https://vite-plugin-mock-dev-server.netlify.app/" target="_blank" rel="noreferrer">vite-plugin-mock-dev-server</a> 作为 mock 服务插件。会自动搜集 <code>vite.server.proxy</code> 的配置，并且拦截请求。</p><h2 id="手动添加" tabindex="-1">手动添加 <a class="header-anchor" href="#手动添加" aria-label="Permalink to &quot;手动添加&quot;">​</a></h2><p>所有入口文件都存放于根目录 mock 文件夹中。其中 shared 文件存放公共内容、工具包，不存放 mock 文件。下面演示如何手动添加：</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">.</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">mock</span></span>
<span class="line"><span style="color:#FFCB6B;">├──├──demo.mock.ts</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p>默认采用 <code>ts</code> 作为 <code>mock</code> 文件后缀。并且为了区分 <code>mock</code> 文件和其他文件，所以默认需要在创建文件时1以：<code>xxx.mock.ts</code> 格式创建，否则不会被匹配生效。</p></div><ul><li>编写 mock</li></ul><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">defineMock</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vite-plugin-mock-dev-server</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> Mock </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">mockjs</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">pagination</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stringify</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">response</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@mock/shared/utils</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">array</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">@mock/shared/database</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> getPersonList </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">defineMock</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">url</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/api/list</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">method</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">GET</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">delay</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">500</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">body</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Mock</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">mock</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">list|1-10</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> [</span></span>
<span class="line"><span style="color:#BABED8;">      </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">id|+1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">    ]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><p>按照上述步骤后，你只需要在接口处使用 /api/list 就会被自动拦截并且替换为 mock 数据了。</p><h2 id="目录与文件命名" tabindex="-1">目录与文件命名 <a class="header-anchor" href="#目录与文件命名" aria-label="Permalink to &quot;目录与文件命名&quot;">​</a></h2><p>微服务架构是当前后端服务采用的主流架构，后端通过 服务名+接口地址 的形式提供接口给到前端进行调用。 在这种场景下，为能够直观的与后端的微服务架构能够有清晰的映射关系，在 mock 目录下，也应该采用类型的目录结构， 划分目录进行管理。</p><p>比如，在一个 电商类的项目中， 后端提供了：</p><ul><li>商品服务：提供了 商品列表、商品详情 等接口</li><li>搜索服务：提供了 关键字搜索、条件筛选 等接口</li><li>订单服务：提供了 订单列表、订单详情 等接口</li><li>支付服务：提供了 支付、取消支付 等接口</li></ul><p>相对应的，我们的 mock目录，也应根据 服务名 来划分目录：</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">./mock</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">goods</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">search</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">order</span></span>
<span class="line"><span style="color:#FFCB6B;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">payment</span></span></code></pre></div><p>对于单服务下的接口，推荐采用 一个接口一个文件的形式进行管理：</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">goods</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">list.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">detail.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">search</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">keywords.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">filters.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">order</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">list.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">│</span><span style="color:#BABED8;">   </span><span style="color:#C3E88D;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">detail.mock.ts</span></span>
<span class="line"><span style="color:#FFCB6B;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">payment</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">payment.mock.ts</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#FFCB6B;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">cancel.mock.ts</span></span></code></pre></div><p>这样做的好处，能够直接通过 目录名和文件名，快速找到对应的接口，方便新建、修改</p><h2 id="构建独立部署的mock服务" tabindex="-1">构建独立部署的mock服务 <a class="header-anchor" href="#构建独立部署的mock服务" aria-label="Permalink to &quot;构建独立部署的mock服务&quot;">​</a></h2><p>该插件提供了在构建时提供一个小型的 <code>mock</code> 服务器，但是需要并不能内联到客户端代码中。所以会在 <code>dist</code> 下生成一个 <code>mockServer</code> 文件，只需要进入该文件，执行 <code>npm i</code> 安装依赖后，执行 <code>npm server</code> 即可启动 <code>mock</code> 服务。</p><h2 id="共享内容" tabindex="-1">共享内容 <a class="header-anchor" href="#共享内容" aria-label="Permalink to &quot;共享内容&quot;">​</a></h2><p>在开发过程中，不可避免会有一些共享的返回数据格式和一些工具方法，该项目中统一存放于 <code>mock/shared</code> 包中。</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">./mock</span></span>
<span class="line"><span style="color:#FFCB6B;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">shared</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#FFCB6B;">├──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">database</span><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;"># 数据</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#FFCB6B;">└──</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">utils</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;"># 工具函数</span></span></code></pre></div>`,28),e=[p];function c(t,r,y,D,i,B){return a(),n("div",null,e)}const E=s(o,[["render",c]]);export{d as __pageData,E as default};
